---
title: 'Florence -200 aniversario Github R-Ladies'
author: "Autor: Oscar Rojo Martín"
date: "Mayo 2020"
output:
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
  pdf_document:
    highlight: zenburn
    toc: yes
  word_document: default
---


# .- Introducción


```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)
library("magrittr")
```

CONCURSO DE ANÁLISIS DE DATOS CON MOTIVO DE LOS 200 AÑOS DEL NACIMIENTO DE FLORENCE NIGHTINGALE

Con el objetivo de conmemorar los 200 años del nacimiento de Florence Nightingale, precursora de la estadística y epidemiología moderna, y primera mujer admitida en la Royal Statistical Society, el colectivo de Rladies España (nodos de Barcelona, Madrid y Bilbao) en colaboración con la Sociedad Española de Biometría y la Sociedad Catalana de Estadística se complace en anunciar el concurso: “200 AÑOS DE FLORENCE NIGHTINGALE”.

El objetivo del concurso consiste en analizar el conjunto de datos que Florence Nightingale utilizó para analizar las causas de mortalidad del ejército británico durante la guerra de Crimea y que sirvió para determinar los factores asociados a la alta mortalidad y reducirla significativamente.

https://github.com/rladies/spain_nightingale/blob/master/README.md

https://github.com/rladies/spain_nightingale/blob/master/datos_florence.xlsx

# .- Data

Cargar los datos en bruto desde github y renombrar las columnas.

```{r pressure, echo=FALSE}
data_raw <- rio::import("https://github.com/rladies/spain_nightingale/raw/master/datos_florence.xlsx")

data <- data_raw[c(-1,-2),]
names(data) <- c("fecha", "ejercito", "muertes_zymotic", "muertes_heridas", "muertes_otras", "muertes_zymotic_anual", "muertes_heridas_anual", "muertes_otras_anual")
data$ejercito <- as.numeric(data$ejercito)
data$muertes_zymotic <- as.numeric(data$muertes_zymotic)
data$muertes_heridas <- as.numeric(data$muertes_heridas)
data$muertes_otras <- as.numeric(data$muertes_otras)
data$muertes_zymotic_anual <- as.numeric(data$muertes_zymotic_anual)
data$muertes_heridas_anual <- as.numeric(data$muertes_heridas_anual)
data$muertes_otras_anual <- as.numeric(data$muertes_otras_anual)
data$fecha[data$fecha == "Aug_1855"] <- "Aug 1855"
data %<>% 
  tidyr::separate(fecha, into = c("m", "y"), sep = " ") %>%
  dplyr::mutate(y = as.numeric(y),
                m = match(m, month.abb),
                fecha = lubridate::make_date(y,m)) %>%
  dplyr::select(-m, -y)
```

Se puede encontrar una explicación de los datos en:
* https://vincentarelbundock.github.io/Rdatasets/doc/HistData/Nightingale.html
* https://understandinguncertainty.org/node/214

Los datos abarcan desde Abril de 1854 hasta Marzo de 1856 (3 años) con periodo mensual. Los datos se dividen en tres partes:

1. Tamaño estimado del ejército (S)
2. Datos sobre las muertes ocurridas en el ejército durante ese mes (D) por infección, por heridas o por otras.
3. Extrapolación de los datos de muertes de ese mes a muertes anuales por 1000 si las circunstancias no cambiasen respecto a dicho mes (N). Estas tres variables permiten comparar los datos mensuales de muertes dado que están en unas unidades comunes.
    
Es decir, los datos correspondientes al tercer punto se calculan usando los del segundo punto mediante la transformación N = 12000 * D / S donde D es el número de muertes ocurridas ese mes, y S es el tamaño estimado del ejercito. Se multiplica por 12000 para transformar las unidades de mensual a anual ( x 12), y a muertes por cada 1000 (x 1000).

```{r}
# Comprobar que las tres últimas columnas se pueden calcular a partir de los datos mensuales
data %>%
  dplyr::mutate(muertes_zymotic_anual_calculada = 12000 * muertes_zymotic / ejercito,
                muertes_heridas_anual_calculada = 12000 * muertes_heridas / ejercito,
                muertes_otras_anual_calculada = 12000 * muertes_otras / ejercito) %>%
  tidyr::gather(muertes_anuales_tipo, muertes_anuales_valor, -fecha, -ejercito, 
                -muertes_zymotic, -muertes_heridas, -muertes_otras) %>%
  ggplot2::ggplot(ggplot2::aes(muertes_anuales_tipo, muertes_anuales_valor)) +
  ggplot2::geom_col() +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, vjust = 1, hjust = 1))
```

Otros aspecto importante a considerar es que en Marzo de 1855 una Comisión Sanitaria fue enviada para mejorar la higiene en los campamentos y hospitales.

```{r}
data$comision <- FALSE
data$comision[data$fecha >= "1855-03-01"] <- TRUE
```

# .- Análisis descriptivo datos extrapolaciones anuales

Mostramos la serie temporal de las muertes anuaelas por mil, en escala logarítmica para poder apreciar mejor las diferencias entre las tres series.

```{r}
data %>%
  dplyr::select(fecha, muertes_zymotic_anual, muertes_heridas_anual, muertes_otras_anual) %>%
  tidyr::gather(muertes_tipo, muertes_valor, -fecha) %>%
  ggplot2::ggplot(ggplot2::aes(x = fecha, y = muertes_valor, col = muertes_tipo)) +
  ggplot2::geom_line() +
  ggplot2::geom_point() +
  ggplot2::scale_y_log10()
```

Se puede apreciar el impacto de la comisión sanitaria en la reducción de muertes por infecciones a partir de su llegada en Marzo de 1855. Florence Nightingale usó unos diagramas llamados "Coxcombs" pero la información que reproducen viasualmente es la misma que en la gráfica anterior.

```{r}
# Representación mediante diagramas "Coxcombs" (usando coordenadas polares)
data %>%
  dplyr::select(fecha, muertes_zymotic_anual, muertes_heridas_anual, muertes_otras_anual) %>%
  tidyr::gather(muertes_tipo, muertes_valor, -fecha) %>%
  dplyr::mutate(muertes_valor_polar = sqrt(muertes_valor / pi)) %>%
  ggplot2::ggplot(ggplot2::aes(x = fecha, y = muertes_valor_polar, fill = muertes_tipo)) +
  ggplot2::geom_col() +
  ggplot2::coord_polar()
```

# .- Preguntas

A partir de este análisis descriptivo hay dos preguntas que pueden formularse:

1. Se puede determinar estadísticamente (e.g., mediante un test de hipótesis) que la tendencia antes de Marzo de 1855 es diferente de la posterior a esa fecha, es decir, que la comisión sanitaria tuvo un impacto real. En caso afirmativo, ¿afectó por igual a las tres causas de muerte?


```{r}
# Separamos 2 periodos
p1 <- data%>%
  dplyr::select(fecha, muertes_zymotic_anual, muertes_heridas_anual, muertes_otras_anual)%>%
  dplyr::filter(fecha < "1855-03-01")

p2 <- data%>%
  dplyr::select(fecha, muertes_zymotic_anual, muertes_heridas_anual, muertes_otras_anual)%>%
  dplyr::filter(fecha > "1855-02-01" & fecha < "1856-01-01")
```

```{r}
#SUPUESTO DE NORMALIDAD: Con el gráfico Q-Q se hace una primera aproximación visual de si hay o no normalidad. Hay que tener en cuenta que este gráfico es meramente descriptivo.
# Gráfico Q-Q
qqnorm( p1$muertes_zymotic_anual) # la nube de puntos
qqline( p1$muertes_zymotic_anual) # la recta

# Gráfico Q-Q
qqnorm( p1$muertes_otras_anual ) # la nube de puntos
qqline( p1$muertes_otras_anual  ) # la recta

# Gráfico Q-Q
qqnorm( p1$muertes_heridas_anual ) # la nube de puntos
qqline( p1$muertes_heridas_anual  ) # la recta


shapiro.test ( p1$muertes_zymotic_anual)

shapiro.test ( p1$muertes_heridas_anual)

shapiro.test ( p1$muertes_otras_anual)

```

La nube de puntos se ordena cerca de la recta. En un principio, visualmente se aprecia que nuestros datos cumplen el supuesto de normalidad.

Con un p-value mayor de 0.05, no podemos rechazar la hipótesis nula. Por lo tanto, podemos concluir que nuestros datos cumplen el supuesto de normalidad. Caso de muertes por zymotic.
Con un p-value menor de 0.05, podemos rechazar la hipótesis nula. Por lo tanto, podemos concluir que nuestros datos no cumplen el supuesto de normalidad. Caso de mas muertes por heridas y las otras

```{r}
#SUPUESTO DE NORMALIDAD: Con el gráfico Q-Q se hace una primera aproximación visual de si hay o no normalidad. Hay que tener en cuenta que este gráfico es meramente descriptivo.
# Gráfico Q-Q
qqnorm( p2$muertes_zymotic_anual) # la nube de puntos
qqline( p2$muertes_zymotic_anual) # la recta

# Gráfico Q-Q
qqnorm( p2$muertes_otras_anual ) # la nube de puntos
qqline( p2$muertes_otras_anual  ) # la recta

# Gráfico Q-Q
qqnorm( p2$muertes_heridas_anual ) # la nube de puntos
qqline( p2$muertes_heridas_anual  ) # la recta


shapiro.test ( p2$muertes_zymotic_anual)

shapiro.test ( p2$muertes_heridas_anual)

shapiro.test ( p2$muertes_otras_anual)

```
Para el segundo periodo. 
La nube de puntos se ordena cerca de la recta. En un principio, visualmente se aprecia que nuestros datos cumplen el supuesto de normalidad.

Con un p-value mayor de 0.05, no podemos rechazar la hipótesis nula. Por lo tanto, podemos concluir que nuestros datos cumplen el supuesto de normalidad. Caso de muertes por heridas.
Con un p-value menor de 0.05, podemos rechazar la hipótesis nula. Por lo tanto, podemos concluir que nuestros datos no cumplen el supuesto de normalidad. Caso de mas muertes por zymotic y las otras


```{r}
# Gráfico Q-Q
qqnorm( p1$muertes_zymotic_anual - p2$muertes_zymotic_anual ) # la nube de puntos
qqline( p1$muertes_zymotic_anual - p2$muertes_zymotic_anual  ) # la recta

# Gráfico Q-Q
qqnorm( p1$muertes_otras_anual - p2$muertes_otras_anual ) # la nube de puntos
qqline( p1$muertes_otras_anual - p2$muertes_otras_anual  ) # la recta

# Gráfico Q-Q
qqnorm( p1$muertes_heridas_anual - p2$muertes_heridas_anual ) # la nube de puntos
qqline( p1$muertes_heridas_anual - p2$muertes_heridas_anual  ) # la recta



# contraste de normalidad
shapiro.test ( data$muertes_zymotic_anual - data$muertes_heridas_anual  )

# contraste de normalidad
shapiro.test ( data$muertes_zymotic_anual - data$muertes_otras_anual  )

# contraste de normalidad
shapiro.test ( data$muertes_otras_anual - data$muertes_heridas_anual )
```
En estos casos tenemos una distribución que es normal puesto que p es < 0.05




```{r}
# SUPUESTO DE HOMOCEDASTICIDAD (homogeneidad de varianzas). En el contraste de homogeneidad de varianzas la hipótesis nula es la varianza es constante (no varía) en los diferentes grupos. Para contrastarla podemos utilizar el test F de Snedecor con var.test( ), que se aplica cuando solo hay dos grupos.
var.test( p1$muertes_zymotic_anual, p2$muertes_zymotic_anual ) # contraste de homogeneidad de varianzas
```
Interpretación: 
Con un p-value = 0.01245, menor de 0.05, podemos rechazar la hipótesis nula. Por lo tanto suponemos que no hay homogeneidad de varianzas.






```{r}

# CONTRASTE DE HIPÓTESIS: Se supone normalidad y homocedasticidad u homogeneidad de varianzas, podemos realizar nuestro contraste.
#Definimos nuestras hipótesis. Queremos probar si la media del primer periodo es distinta de la media del segundo periodo para las muertes por zymotic. Por lo tanto, tenemos que:
#Hipótesis nula es H0:μH=μM
#Hipótesis alternativa es H1:μH≠μM
#Realizamos el contraste. Para la prueba t para dos muestras independientes usamos la función t.test( ), sobre muestras independientes paired = FALSE, en un contraste bilateral (de dos colas) alternative = "two.sided".

t.test( p1$muertes_zymotic_anual, p2$muertes_zymotic_anual, # dos muestras 
        alternative = "two.sided", # contraste bilateral 
        paired = FALSE, # muestras independientes
        var.equal = TRUE ) # se supone homocedasticidad
```
Interpretamos los resultados. Con un p-value = 0.0596 mayor de 0.05 no podemos rechazar la hipótesis nula H0 de igualdad de medias. Esto es, no hay diferencias significativas entre las medias. Podemos concluir que la media del primer periodo y la media del segundo no son distintas para las muertes por zymotic.






2. ¿Qué hubiera pasado si la comisión sanitaria no hubiera sido enviada?


```{r}
# Seleccionamos el periodo anteriores a su trabajo
ts_zymotic <- ts(data$muertes_zymotic_anual, frequency = 12, start = c(1854,5), end = c(1855,2)) 
str(ts_zymotic)
ts_zymotic

# Empleo la función auto.arima() para determinar las (p,d,q) adecuadas

forecast::auto.arima(ts_zymotic)

# Realizo una predicción para los 12 meses siguientes

forecast::forecast(forecast::auto.arima(ts_zymotic))

# Lo mostramos gráficamente

forecast::autoplot(forecast::forecast(forecast::auto.arima(ts_zymotic)), 10)
```
```{r}
# Usando el paquete prophet de Facebook. El único requisito es que los datos tengan una columna con las fechas de las observaciones llamada ds,y la columna de valores y

data_prophet <- data%>%
  dplyr::select(fecha,muertes_zymotic_anual)%>%
  dplyr::filter(fecha<"1855-03-01") # selecciono los valores hasta el 01/03/1855
names(data_prophet)<-c("ds","y") # cambio los nombres de las columnas



```
```{r}
m= prophet::prophet(data_prophet)
m
# creamos el data.frame de base para el forecast con la función, incluida en el paquete, llamada make_future_dataframe. Y finalmente, usando la función genérica predict calculamos nuestro forecast.
future_df_prophet <- prophet::make_future_dataframe(m, periods = 24, freq = "months")
forecast <- predict(m, future_df_prophet)
tail(forecast[c("ds", "yhat", "yhat_lower","yhat_upper")], 12) # muestra de las últimas 12 filas de las columnas 1 y 2

# vemos el resultado de la predicción.
plot(m ,forecast) 
prophet::prophet_plot_components(m ,forecast)

```
```{r}
# Vemos la gráfica de forma interactiva
prophet::dyplot.prophet(m, forecast)
```


